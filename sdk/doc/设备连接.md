# 设备连接

在阅读本章节前，请先确认已完成《SDK 导入》章节中的依赖和初始化工作。本章节主要介绍 CXR-M SDK 在蓝牙与 Wi-Fi 链路上的集成方式，帮助移动端快速与 Rokid 智能眼镜建立稳定连接。

## Bluetooth 连接

### 1. 查找蓝牙设备

可通过标准 Android `Bluetooth` API 进行设备发现。扫描时建议使用服务 UUID `00009100-0000-1000-8000-00805f9b34fb` 过滤 Rokid 眼镜，提高效率。示例辅助类摘录如下：

```kotlin
package com.rokid.cxrandroiddocsample.helpers

// imports ...

class BluetoothHelper(
    val context: AppCompatActivity,
    val initStatus: (INIT_STATUS) -> Unit,
    val deviceFound: () -> Unit
) {

    companion object {
        const val TAG = "Rokid Glasses CXR-M"
        const val REQUEST_CODE_PERMISSIONS = 100

        private val REQUIRED_PERMISSIONS = mutableListOf(
            Manifest.permission.ACCESS_FINE_LOCATION,
            Manifest.permission.BLUETOOTH,
            Manifest.permission.BLUETOOTH_ADMIN,
        ).apply {
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.S) {
                add(Manifest.permission.BLUETOOTH_SCAN)
                add(Manifest.permission.BLUETOOTH_CONNECT)
            }
        }.toTypedArray()

        enum class INIT_STATUS {
            NotStart,
            INITING,
            INIT_END
        }
    }

    val scanResultMap: ConcurrentHashMap<String, BluetoothDevice> = ConcurrentHashMap()
    val bondedDeviceMap: ConcurrentHashMap<String, BluetoothDevice> = ConcurrentHashMap()

    private val scanner by lazy {
        adapter?.bluetoothLeScanner ?: run {
            Toast.makeText(context, "Bluetooth is not supported", Toast.LENGTH_SHORT).show()
            showRequestPermissionDialog()
            throw Exception("Bluetooth is not supported!!")
        }
    }

    @SuppressLint("MissingPermission")
    private val bluetoothEnabled = MutableLiveData<Boolean>().apply {
        observe(context) {
            if (value == true) {
                initStatus.invoke(INIT_STATUS.INIT_END)
                startScan()
            } else {
                showRequestBluetoothEnableDialog()
            }
        }
    }

    private val requestBluetoothEnable =
        context.registerForActivityResult(ActivityResultContracts.StartActivityForResult()) { result ->
            if (result.resultCode == Activity.RESULT_OK) {
                adapter = manager?.adapter
            } else {
                showRequestBluetoothEnableDialog()
            }
        }

    private var adapter: BluetoothAdapter? = null
        set(value) {
            field = value
            value?.let {
                if (!it.isEnabled) {
                    requestBluetoothEnable.launch(Intent(BluetoothAdapter.ACTION_REQUEST_ENABLE))
                } else {
                    bluetoothEnabled.postValue(true)
                }
            }
        }

    private var manager: BluetoothManager? = null
        set(value) {
            field = value
            initStatus.invoke(INIT_STATUS.INITING)
            value?.let {
                adapter = it.adapter
            } ?: run {
                Toast.makeText(context, "Bluetooth is not supported", Toast.LENGTH_SHORT).show()
                showRequestPermissionDialog()
            }
        }

    val permissionResult = MutableLiveData<Boolean>().apply {
        observe(context) {
            if (it == true) {
                manager =
                    context.getSystemService(AppCompatActivity.BLUETOOTH_SERVICE) as BluetoothManager
            } else {
                showRequestPermissionDialog()
            }
        }
    }

    val scanListener = object : ScanCallback() {
        @SuppressLint("MissingPermission")
        override fun onScanResult(callbackType: Int, result: ScanResult?) {
            super.onScanResult(callbackType, result)
            result?.device?.name?.let {
                scanResultMap[it] = result.device
                deviceFound.invoke()
            }
        }

        override fun onScanFailed(errorCode: Int) {
            super.onScanFailed(errorCode)
            Toast.makeText(context, "Scan Failed $errorCode", Toast.LENGTH_SHORT).show()
        }
    }

    fun checkPermissions() {
        initStatus.invoke(INIT_STATUS.NotStart)
        context.requestPermissions(REQUIRED_PERMISSIONS, REQUEST_CODE_PERMISSIONS)
        context.registerReceiver(
            bluetoothStateListener,
            IntentFilter(BluetoothAdapter.ACTION_STATE_CHANGED)
        )
    }

    @SuppressLint("MissingPermission")
    fun release() {
        context.unregisterReceiver(bluetoothStateListener)
        stopScan()
        permissionResult.postValue(false)
        bluetoothEnabled.postValue(false)
    }

    private fun showRequestPermissionDialog() { /* ... */ }
    private fun showRequestBluetoothEnableDialog() { /* ... */ }

    @SuppressLint("MissingPermission")
    @RequiresPermission(Manifest.permission.BLUETOOTH_SCAN)
    fun startScan() {
        scanResultMap.clear()
        val connectedList = getConnectedDevices()
        connectedList.forEach { device ->
            device.name?.let {
                if (it.contains("Glasses", false)) {
                    bondedDeviceMap[it] = device
                    deviceFound.invoke()
                }
            }
        }

        adapter?.bondedDevices?.forEach { d ->
            d.name?.let {
                if (it.contains("Glasses", false) && bondedDeviceMap[it] == null) {
                    bondedDeviceMap[it] = d
                }
                deviceFound.invoke()
            }
        }

        try {
            scanner.startScan(
                listOf(
                    ScanFilter.Builder()
                        .setServiceUuid(
                            ParcelUuid.fromString("00009100-0000-1000-8000-00805f9b34fb")
                        )
                        .build()
                ),
                ScanSettings.Builder().build(),
                scanListener
            )
        } catch (e: Exception) {
            Toast.makeText(context, "Scan Failed ${e.message}", Toast.LENGTH_SHORT).show()
        }
    }

    @RequiresPermission(Manifest.permission.BLUETOOTH_SCAN)
    fun stopScan() {
        scanner.stopScan(scanListener)
    }

    @SuppressLint("MissingPermission")
    private fun getConnectedDevices(): List<BluetoothDevice> {
        return adapter?.bondedDevices?.filter { device ->
            try {
                device::class.java.getMethod("isConnected").invoke(device) as Boolean
            } catch (_: Exception) {
                Toast.makeText(context, "Get Connected Devices Failed", Toast.LENGTH_SHORT).show()
                false
            }
        } ?: emptyList()
    }

    val bluetoothStateListener = object : BroadcastReceiver() {
        override fun onReceive(context: Context?, intent: Intent?) {
            if (intent?.action == BluetoothAdapter.ACTION_STATE_CHANGED) {
                val state = intent.getIntExtra(BluetoothAdapter.EXTRA_STATE, BluetoothAdapter.ERROR)
                if (state == BluetoothAdapter.STATE_OFF) {
                    initStatus.invoke(INIT_STATUS.NotStart)
                    bluetoothEnabled.postValue(false)
                }
            }
        }
    }
}
```

> **注意**：示例中的 Dialog 与权限弹窗只做流程展示，实际项目可结合 Compose 或其他 UI 框架实现。

### 2. 初始化蓝牙模块

蓝牙扫描后，调用 `CxrApi.getInstance().initBluetooth(context, device, callback)` 获取眼镜的连接信息：

```kotlin
fun initDevice(context: Context, device: BluetoothDevice) {
    CxrApi.getInstance().initBluetooth(
        context,
        device,
        object : BluetoothStatusCallback {
            override fun onConnectionInfo(
                socketUuid: String?,
                macAddress: String?,
                rokidAccount: String?,
                glassesType: Int
            ) {
                socketUuid?.let { uuid ->
                    macAddress?.let { mac ->
                        connect(context, uuid, mac)
                    } ?: Log.e(TAG, "macAddress is null")
                } ?: Log.e(TAG, "socketUuid is null")
            }

            override fun onConnected() { /* 蓝牙已连接 */ }
            override fun onDisconnected() { /* 蓝牙断开 */ }
            override fun onFailed(error: ValueUtil.CxrBluetoothErrorCode?) {
                Log.e(TAG, "Init failed $error")
            }
        }
    )
}
```

### 3. 连接蓝牙模块

在获取到 `socketUuid` 与 `macAddress` 后，通过 `connectBluetooth` 建立实际通信通道：

```kotlin
fun connect(context: Context, socketUuid: String, macAddress: String) {
    CxrApi.getInstance().connectBluetooth(
        context,
        socketUuid,
        macAddress,
        object : BluetoothStatusCallback {
            override fun onConnectionInfo(
                socketUuid: String?,
                macAddress: String?,
                rokidAccount: String?,
                glassesType: Int
            ) {
                // 可在此处理补充信息
            }

            override fun onConnected() { Log.d(TAG, "Connected") }
            override fun onDisconnected() { Log.d(TAG, "Disconnected") }
            override fun onFailed(error: ValueUtil.CxrBluetoothErrorCode?) {
                Log.e(TAG, "Failed $error")
            }
        }
    )
}
```

### 4. 获取蓝牙连接状态

```kotlin
fun getConnectionStatus(): Boolean {
    return CxrApi.getInstance().isBluetoothConnected
}
```

### 5. 反初始化蓝牙

```kotlin
fun deInit() {
    CxrApi.getInstance().deinitBluetooth()
}
```

### 6. 蓝牙重连

重连逻辑与 `connectBluetooth` 一致，只需保持最新的 `socketUuid` 与 `macAddress`：

```kotlin
fun reconnect(context: Context, socketUuid: String, macAddress: String) {
    CxrApi.getInstance().connectBluetooth(
        context,
        socketUuid,
        macAddress,
        object : BluetoothStatusCallback {
            override fun onConnectionInfo(
                socketUuid: String?,
                macAddress: String?,
                rokidAccount: String?,
                glassesType: Int
            ) { /* 更新缓存 */ }

            override fun onConnected() { Log.d(TAG, "Connected") }
            override fun onDisconnected() { Log.d(TAG, "Disconnected") }
            override fun onFailed(error: ValueUtil.CxrBluetoothErrorCode?) {
                Log.e(TAG, "Reconnect failed: $error")
            }
        }
    )
}
```

## Wi-Fi 连接

> **提示**：Wi-Fi P2P 模块依赖蓝牙通道完成密钥交换，将在蓝牙连接成功后再执行。由于功耗较高，建议在需要同步媒体或大数据时才启用。

### 1. 初始化 Wi-Fi 通信模块

```kotlin
fun initWifi(): ValueUtil.CxrStatus? {
    return CxrApi.getInstance().initWifiP2P(
        object : WifiP2PStatusCallback {
            override fun onConnected() { Log.d(TAG, "onConnected") }
            override fun onDisconnected() { Log.d(TAG, "onDisconnected") }
            override fun onFailed(errorCode: ValueUtil.CxrWifiErrorCode?) {
                Log.e(TAG, "Init wifi failed $errorCode")
            }
        }
    )
}
```

返回值 `ValueUtil.CxrStatus` 标识请求是否成功、等待或失败。

### 2. 获取 Wi-Fi 连接状态

```kotlin
fun getWifiConnectionStatus(): Boolean {
    return CxrApi.getInstance().isWifiP2PConnected
}
```

### 3. 反初始化 Wi-Fi 模块

```kotlin
fun deinitWifi() {
    CxrApi.getInstance().deinitWifiP2P()
}
```

## 开发建议

- **权限管理**：遵循 Android 12+ 蓝牙权限拆分要求，提前处理前台服务通知与授权文案。
- **生命周期**：在 `onStop()` 或 `onDestroy()` 中释放扫描、广播等资源，避免泄漏。
- **错误重试**：根据 `BluetoothStatusCallback` 与 `WifiP2PStatusCallback` 的错误码，决定是否自动重试或引导用户手动处理。
- **日志规范**：保持日志内容为英文，符合项目关于日志的统一规范。

通过上述步骤，即可完成 CXR-M SDK 在设备连接能力上的基础集成，为后续的文本传输、媒体同步等业务能力打下良好基础。

