# 蓝牙与Wi-Fi连接指南

## Bluetooth 连接

### 1 查找蓝牙设备

通过Android标准Bluetooth接口进行设备查找，扫描过程中可使用UUID：`00009100-0000-1000-8000-00805f9b34fb`来过滤Rokid设备。

#### 代码示例：

```kotlin
package com.rokid.cxrandroiddocsample.helpers

//imports

/**
 * Bluetooth Helper
 * @author rokid
 * @date 2025/04/27
 * @param context Activity Register Context
 * @param initStatus Init Status
 * @param deviceFound Device Found
 */
class BluetoothHelper(
    val context: AppCompatActivity,
    val initStatus: (INIT_STATUS) -> Unit,
    val deviceFound: () -> Unit
) {
    companion object {
        const val TAG = "Rokid Glasses CXR-M"
        
        // Request Code
        const val REQUEST_CODE_PERMISSIONS = 100
        
        // Required Permissions
        private val REQUIRED_PERMISSIONS = mutableListOf(
            Manifest.permission.ACCESS_FINE_LOCATION,
            Manifest.permission.BLUETOOTH,
            Manifest.permission.BLUETOOTH_ADMIN,
        ).apply {
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.S) {
                add(Manifest.permission.BLUETOOTH_SCAN)
                add(Manifest.permission.BLUETOOTH_CONNECT)
            }
        }.toTypedArray()
        
        // Init Status
        enum class INIT_STATUS {
            NotStart, INITING, INIT_END
        }
    }
    
    // Scan Results
    val scanResultMap: ConcurrentHashMap<String, BluetoothDevice> = ConcurrentHashMap()
    
    // Bonded Devices
    val bondedDeviceMap: ConcurrentHashMap<String, BluetoothDevice> = ConcurrentHashMap()
    
    // Scanner
    private val scanner by lazy {
        adapter?.bluetoothLeScanner ?: run {
            Toast.makeText(context, "Bluetooth is not supported", Toast.LENGTH_SHORT).show()
            showRequestPermissionDialog()
            throw Exception("Bluetooth is not supported!!")
        }
    }
    
    // Bluetooth Enabled
    @SuppressLint("MissingPermission")
    private val bluetoothEnabled: MutableLiveData<Boolean> = MutableLiveData<Boolean>().apply {
        this.observe(context) {
            if (this.value == true) {
                initStatus.invoke(INIT_STATUS.INIT_END)
                startScan()
            } else {
                showRequestBluetoothEnableDialog()
            }
        }
    }
    
    // Bluetooth State Listener
    private val requestBluetoothEnable = context.registerForActivityResult(
        ActivityResultContracts.StartActivityForResult()
    ) { result ->
        if (result.resultCode == Activity.RESULT_OK) {
            adapter = manager?.adapter
        } else {
            showRequestBluetoothEnableDialog()
        }
    }
    
    // Bluetooth Adapter
    private var adapter: BluetoothAdapter? = null
        set(value) {
            field = value
            value?.let {
                if (!it.isEnabled) {
                    //to Enable it
                    requestBluetoothEnable.launch(Intent(BluetoothAdapter.ACTION_REQUEST_ENABLE))
                } else {
                    bluetoothEnabled.postValue(true)
                }
            }
        }
    
    // Bluetooth Manager
    private var manager: BluetoothManager? = null
        set(value) {
            field = value
            initStatus.invoke(INIT_STATUS.INITING)
            value?.let {
                adapter = it.adapter
            } ?: run {
                Toast.makeText(context, "Bluetooth is not supported", Toast.LENGTH_SHORT).show()
                showRequestPermissionDialog()
            }
        }
    
    // Permission Result
    val permissionResult: MutableLiveData<Boolean> = MutableLiveData<Boolean>().apply {
        this.observe(context) {
            if (it == true) {
                manager = context.getSystemService(AppCompatActivity.BLUETOOTH_SERVICE) as BluetoothManager
            } else {
                showRequestPermissionDialog()
            }
        }
    }
    
    // Scan Listener
    val scanListener = object : ScanCallback() {
        @SuppressLint("MissingPermission")
        override fun onScanResult(callbackType: Int, result: ScanResult?) {
            super.onScanResult(callbackType, result)
            result?.let { r ->
                r.device.name?.let {
                    scanResultMap[it] = r.device
                    deviceFound.invoke()
                }
            }
        }
        
        override fun onScanFailed(errorCode: Int) {
            super.onScanFailed(errorCode)
            Toast.makeText(
                context, "Scan Failed $errorCode", Toast.LENGTH_SHORT
            ).show()
        }
    }
    
    // check permissions
    fun checkPermissions() {
        initStatus.invoke(INIT_STATUS.NotStart)
        context.requestPermissions(REQUIRED_PERMISSIONS, REQUEST_CODE_PERMISSIONS)
        context.registerReceiver(
            bluetoothStateListener,
            IntentFilter(BluetoothAdapter.ACTION_STATE_CHANGED)
        )
    }
    
    // Release
    @SuppressLint("MissingPermission")
    fun release() {
        context.unregisterReceiver(bluetoothStateListener)
        stopScan()
        permissionResult.postValue(false)
        bluetoothEnabled.postValue(false)
    }
    
    // Show Request Permission Dialog
    private fun showRequestPermissionDialog() {
        AlertDialog.Builder(context)
            .setTitle("Permission")
            .setMessage("Please grant the permission")
            .setPositiveButton("OK") { _, _ ->
                context.requestPermissions(
                    REQUIRED_PERMISSIONS,
                    REQUEST_CODE_PERMISSIONS
                )
            }
            .setNegativeButton("Cancel") { _, _ ->
                Toast.makeText(
                    context, "Permission does not granted, FINISH", Toast.LENGTH_SHORT
                ).show()
                context.finish()
            }
            .show()
    }
    
    // Show Request Bluetooth Enable Dialog
    private fun showRequestBluetoothEnableDialog() {
        AlertDialog.Builder(context)
            .setTitle("Bluetooth")
            .setMessage("Please enable the bluetooth")
            .setPositiveButton("OK") { _, _ ->
                requestBluetoothEnable.launch(Intent(BluetoothAdapter.ACTION_REQUEST_ENABLE))
            }
            .setNegativeButton("Cancel") { _, _ ->
                Toast.makeText(
                    context, "Bluetooth does not enabled, FINISH", Toast.LENGTH_SHORT
                ).show()
                context.finish()
            }
            .show()
    }
    
    // Start Scan
    @SuppressLint("MissingPermission")
    @RequiresPermission(Manifest.permission.BLUETOOTH_SCAN)
    fun startScan() {
        scanResultMap.clear()
        val connectedList = getConnectedDevices()
        for (device in connectedList) {
            device.name?.let {
                if (it.contains("Glasses", false)) {
                    bondedDeviceMap[it] = device
                    deviceFound.invoke()
                }
            }
        }
        adapter?.bondedDevices?.forEach { d ->
            d.name?.let {
                if (it.contains("Glasses", false)) {
                    if (bondedDeviceMap[it] == null) {
                        bondedDeviceMap[it] = d
                    }
                }
                deviceFound.invoke()
            }
        }
        try {
            scanner.startScan(
                listOf<ScanFilter>(
                    ScanFilter.Builder()
                        .setServiceUuid(ParcelUuid.fromString("00009100-0000-1000-8000-00805f9b34fb"))//Rokid Glasses Service
                        .build()
                ),
                ScanSettings.Builder().build(),
                scanListener
            )
        } catch (e: Exception) {
            Toast.makeText(context, "Scan Failed ${e.message}", Toast.LENGTH_SHORT).show()
        }
    }
    
    // Stop Scan
    @RequiresPermission(Manifest.permission.BLUETOOTH_SCAN)
    fun stopScan() {
        scanner.stopScan(scanListener)
    }
    
    // Get Connected Devices
    @SuppressLint("MissingPermission")
    private fun getConnectedDevices(): List<BluetoothDevice> {
        return adapter?.bondedDevices?.filter { device ->
            try {
                val isConnected = device::class.java.getMethod("isConnected").invoke(device) as Boolean
                isConnected
            } catch (_: Exception) {
                Toast.makeText(context, "Get Connected Devices Failed", Toast.LENGTH_SHORT).show()
                false
            }
        } ?: emptyList()
    }
    
    // Bluetooth State Listener
    val bluetoothStateListener = object : BroadcastReceiver() {
        override fun onReceive(context: Context?, intent: Intent?) {
            val action = intent?.action
            if (action == BluetoothAdapter.ACTION_STATE_CHANGED) {
                val state = intent.getIntExtra(BluetoothAdapter.EXTRA_STATE, BluetoothAdapter.ERROR)
                when (state) {
                    BluetoothAdapter.STATE_OFF -> {
                        initStatus.invoke(INIT_STATUS.NotStart)
                        bluetoothEnabled.postValue(false)
                    }
                }
            }
        }
    }
}
```

### 2 初始化蓝牙获取蓝牙信息

设备初始化通过CXR_M SDK的CxrApi类进行控制。

初始化蓝牙模块方法：`fun initBluetooth(context: Context, device: BluetoothDevice, callback: BluetoothStatusCallback)`

#### 代码示例：

```kotlin
/**
 * Init Bluetooth
 *
 * @param context Application Context
 * @param device Bluetooth Device
 */
fun initDevice(context: Context, device: BluetoothDevice){
    /**
     * Init Bluetooth
     *
     * @param context Application Context
     * @param device Bluetooth Device
     * @param callback Bluetooth Status Callback
     */
    CxrApi.getInstance().initBluetooth(context, device, object : BluetoothStatusCallback{
        /**
         * Connection Info
         *
         * @param socketUuid Socket UUID
         * @param macAddress Classic Bluetooth MAC Address
         * @param rokidAccount Rokid Account
         * @param glassesType Device Type, 0-no display, 1-have display
         */
        override fun onConnectionInfo(
            socketUuid: String?,
            macAddress: String?,
            rokidAccount: String?,
            glassesType: Int
        ) {
            socketUuid?.let { uuid ->
                macAddress?.let { address->
                    connect(context, uuid, address)
                }?:run {
                    Log.e(TAG, "macAddress is null")
                }
            }?:run{
                Log.e(TAG, "socketUuid is null")
            }
        }
        
        /**
         * Connected
         */
        override fun onConnected() {
            
        }
        
        /**
         * Disconnected
         */
        override fun onDisconnected() {
            
        }
        
        /**
         * Failed
         *
         * @param errorCode Error Code:
         * @see ValueUtil.CxrBluetoothErrorCode
         * @see ValueUtil.CxrBluetoothErrorCode.PARAM_INVALID Parameter Invalid
         * @see ValueUtil.CxrBluetoothErrorCode.BLE_CONNECT_FAILED BLE Connect Failed
         * @see ValueUtil.CxrBluetoothErrorCode.SOCKET_CONNECT_FAILED Socket Connect Failed
         * @see ValueUtil.CxrBluetoothErrorCode.UNKNOWN Unknown
         */
        override fun onFailed(p0: ValueUtil.CxrBluetoothErrorCode?) {
            
        }
    })
}
```

**BluetoothStatusCallback接口说明：**
- `fun onConnected()`：蓝牙连接成功时回调
- `fun onDisconnected()`：蓝牙连接丢失时回调
- `fun onConnectionInfo(socketUuid: String?, macAddress: String?, rokidAccount: String?, glassesType: Int)`：设备信息更新接口
  - `socketUuid`：设备UUID
  - `macAddress`：设备mac地址
  - `rokidAccount`：Rokid账号
  - `glassesType`：眼镜类型（0-无显示，1-有显示）

### 3 连接蓝牙模块

设备连接通过CXR_M SDK的CxrApi类进行控制。

初始化蓝牙模块方法：`fun connectBluetooth(context: Context, socketUuid: String, macAddress: String, callback: BluetoothStatusCallback)`

#### 代码示例：

```kotlin
/**
 * Connect
 *
 * @param context Application Context
 * @param socketUuid Socket UUID
 * @param macAddress Classic Bluetooth MAC Address
 */
fun connect(context: Context, socketUuid: String, macAddress: String){
    /**
     * Connect
     */
    CxrApi.getInstance().connectBluetooth(context, socketUuid, macAddress, object : BluetoothStatusCallback{
        /**
         * Connection Info
         *
         * @param socketUuid Socket UUID
         * @param macAddress Classic Bluetooth MAC Address
         * @param rokidAccount Rokid Account
         * @param glassesType Device Type, 0-no display, 1-have display
         */
        override fun onConnectionInfo(
            socketUuid: String?,
            macAddress: String?,
            rokidAccount: String?,
            glassesType: Int
        ) {
            //
        }
        
        /**
         * Connected
         */
        override fun onConnected() {
            Log.d(TAG, "Connected")
        }
        
        /**
         * Disconnected
         */
        override fun onDisconnected() {
            Log.d(TAG, "Disconnected")
        }
        
        /**
         * Failed
         *
         * @param errorCode Error Code:
         * @see ValueUtil.CxrBluetoothErrorCode
         * @see ValueUtil.CxrBluetoothErrorCode.PARAM_INVALID Parameter Invalid
         * @see ValueUtil.CxrBluetoothErrorCode.BLE_CONNECT_FAILED BLE Connect Failed
         * @see ValueUtil.CxrBluetoothErrorCode.SOCKET_CONNECT_FAILED Socket Connect Failed
         * @see ValueUtil.CxrBluetoothErrorCode.UNKNOWN Unknown
         */
        override fun onFailed(p0: ValueUtil.CxrBluetoothErrorCode?) {
            Log.e(TAG, "Failed")
        }
    })
}
```

### 4 获取蓝牙通信模块连接状态

通过`fun isBluetoothConnected():Boolean`方法获取当前蓝牙通信模块的连接状态。

**返回值:**
- `true`：蓝牙通信模块已连接
- `false`：蓝牙模块未连接

#### 代码示例：

```kotlin
/**
 * Get Connection Status
 *
 * @return Connection Status: true-connected, false-disconnected
 */
fun getConnectionStatus(): Boolean{
    return CxrApi.getInstance().isBluetoothConnected
}
```

### 5 反初始化蓝牙

通过`fun deinitBluetooth()`方法反初始化蓝牙。

#### 代码示例：

```kotlin
/**
 * DeInit Bluetooth
 */
fun deInit(){
    CxrApi.getInstance().deinitBluetooth()
}
```

### 6 蓝牙重连

通过`fun connectBluetooth(context: Context, sockectUuid: String, macAddress: String, callback: BluetoothStatusCallback)`方法进行蓝牙重连。

**参数说明：**
- `sockectUuid`: UUID
- `macAddress`: Mac地址

#### 代码示例：

```kotlin
/**
 * Connect
 *
 * @param context Application Context
 * @param socketUuid Socket UUID
 * @param macAddress Classic Bluetooth MAC Address
 */
fun connect(context: Context, socketUuid: String, macAddress: String){
    /**
     * Connect
     */
    CxrApi.getInstance().connectBluetooth(context, socketUuid, macAddress, object : BluetoothStatusCallback{
        /**
         * Connection Info
         *
         * @param socketUuid Socket UUID
         * @param macAddress Classic Bluetooth MAC Address
         * @param rokidAccount Rokid Account
         * @param glassesType Device Type, 0-no display, 1-have display
         */
        override fun onConnectionInfo(
            socketUuid: String?,
            macAddress: String?,
            rokidAccount: String?,
            glassesType: Int
        ) {
            //
        }
        
        /**
         * Connected
         */
        override fun onConnected() {
            Log.d(TAG, "Connected")
        }
        
        /**
         * Disconnected
         */
        override fun onDisconnected() {
            Log.d(TAG, "Disconnected")
        }
        
        /**
         * Failed
         *
         * @param errorCode Error Code:
         * @see ValueUtil.CxrBluetoothErrorCode
         * @see ValueUtil.CxrBluetoothErrorCode.PARAM_INVALID Parameter Invalid
         * @see ValueUtil.CxrBluetoothErrorCode.BLE_CONNECT_FAILED BLE Connect Failed
         * @see ValueUtil.CxrBluetoothErrorCode.SOCKET_CONNECT_FAILED Socket Connect Failed
         * @see ValueUtil.CxrBluetoothErrorCode.UNKNOWN Unknown
         */
        override fun onFailed(p0: ValueUtil.CxrBluetoothErrorCode?) {
            Log.e(TAG, "Failed")
        }
    })
}
```

## Wi-Fi 连接

> **注意**：Wi-Fi模块使用前，请先完成蓝牙连接。Wi-Fi模块为高耗能模块，请仅在必须的时候开启。

### 1 初始化Wi-Fi通信模块

使用`fun initWifi(callback: WifiP2PStatusCallback): ValueUtil.CxrStatus`初始化Wi-Fi通信模块。

**WifiP2PStatusCallback接口：**
- `onConnected`: 连接成功时回调
- `onDisconnected`: 断开连接时回调
- `onFailed`: 连接失败时回调
  - `CxrWifiErrorCode.WIFI_DISABLED`: 手机Wi-Fi未打开
  - `CxrWifiErrorCode.WIFI_CONNECT_FAILED`: P2P连接失败
  - `CxrWifiErrorCode.UNKNOWN`: 未知错误

#### 代码示例：

```kotlin
/**
 * Init Wifi
 *
 * @return Status:
 * @see ValueUtil.CxrStatus
 * @see ValueUtil.CxrStatus.REQUEST_SUCCEED Success
 * @see ValueUtil.CxrStatus.REQUEST_WAITING Waiting
 * @see ValueUtil.CxrStatus.REQUEST_FAILED Failed
 */
fun initWifi(): ValueUtil.CxrStatus?{
    return CxrApi.getInstance().initWifiP2P(object : WifiP2PStatusCallback{
        /**
         * Connected
         */
        override fun onConnected() {
            Log.d(TAG, "onConnected")
        }
        
        /**
         * Disconnected
         */
        override fun onDisconnected() {
            Log.d(TAG, "onDisconnected")
        }
        
        /**
         * Failed
         *
         * @param errorCode Error Code:
         * @see ValueUtil.CxrWifiErrorCode
         * @see ValueUtil.CxrWifiErrorCode.WIFI_DISABLED Mobile Phone Wi-Fi disabled
         * @see ValueUtil.CxrWifiErrorCode.WIFI_CONNECT_FAILED Wi-Fi P2P Connect Failed
         * @see ValueUtil.CxrWifiErrorCode.UNKNOWN Unknown
         */
        override fun onFailed(errorCode: ValueUtil.CxrWifiErrorCode?) {
            
        }
    })
}
```

### 2 获取Wi-Fi通信模块连接状态

通过`fun isWifiConnected(): Boolean`方法获取当前Wi-Fi通信模块的连接状态。

**返回值:**
- `true`：Wi-Fi通信模块已连接
- `false`：Wi-Fi通信模块未连接

#### 代码示例：

```kotlin
/**
 * Get Wifi Connection Status
 *
 * @return Connection Status: true-connected, false-disconnected
 */
fun getWiFiConnectionStatus(): Boolean{
    return CxrApi.getInstance().isWifiP2PConnected
}
```

### 3 反初始化Wi-Fi通信模块

通过`public void deinitWifi()`方法反初始化Wi-Fi通信模块。

#### 代码示例：

```kotlin
/**
 * Deinit Wifi
 */
private fun deinitWifi(){
    CxrApi.getInstance().deinitWifiP2P()
}
```