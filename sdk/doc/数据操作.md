# 数据操作

> 进行数据传输前，请确保蓝牙链接已建立且稳定。同步媒体文件前还需初始化 Wi-Fi 通信模块。

## 1. 向眼镜端发送数据流

`sendStream(type, stream, fileName, callback)` 可将文本、图像等数据通过蓝牙发送至眼镜。

```kotlin
private val streamCallback = object : SendStatusCallback {
    override fun onSendSucceed() {
        // 发送成功
    }

    override fun onSendFailed(errorCode: ValueUtil.CxrSendErrorCode?) {
        // 发送失败，errorCode 可能为 PARAM_INVALID / TIMEOUT 等
    }
}

fun sendStream(
    type: ValueUtil.CxrStreamType,
    stream: ByteArray,
    fileName: String
): ValueUtil.CxrStatus? {
    return CxrApi.getInstance().sendStream(type, stream, fileName, streamCallback)
}
```

常用 `CxrStreamType`：
- `WORD_TIPS`：提词文本
- `TRANSCRIPT`：转写数据等

## 2. 读取未同步媒体文件数量

`getUnsyncNum(callback)` 可查询眼镜端尚未同步到移动端的音频、图片、视频数量。

```kotlin
private val unsyncCallback = object : UnsyncNumResultCallback {
    override fun onUnsyncNumResult(
        status: ValueUtil.CxrStatus?,
        audioNum: Int,
        pictureNum: Int,
        videoNum: Int
    ) {
        // status: RESPONSE_SUCCEED / RESPONSE_INVALID / RESPONSE_TIMEOUT
    }
}

fun getUnsyncNum(): ValueUtil.CxrStatus? {
    return CxrApi.getInstance().getUnsyncNum(unsyncCallback)
}
```

## 3. 监听媒体文件更新

注册 `MediaFilesUpdateListener` 以便在眼镜端生成新的照片/视频/音频时及时获知。

```kotlin
private val mediaFilesUpdateListener = object : MediaFilesUpdateListener {
    override fun onMediaFilesUpdated() {
        // 媒体文件发生更新，可触发同步
    }
}

fun setMediaFilesUpdateListener(enable: Boolean) {
    CxrApi.getInstance().setMediaFilesUpdateListener(
        if (enable) mediaFilesUpdateListener else null
    )
}
```

## 4. 同步媒体文件

同步操作需要依赖 Wi-Fi P2P，请先完成 `initWifiP2P`。

### 4.1 同步指定类型的所有文件

```kotlin
private val syncCallback = object : SyncStatusCallback {
    override fun onSyncStart() { /* 同步开始 */ }
    override fun onSingleFileSynced(fileName: String?) { /* 单个文件完成 */ }
    override fun onSyncFailed() { /* 同步失败 */ }
    override fun onSyncFinished() { /* 同步结束 */ }
}

fun startSync(savePath: String, types: Array<ValueUtil.CxrMediaType>): Boolean {
    return CxrApi.getInstance().startSync(savePath, types, syncCallback)
}
```

`ValueUtil.CxrMediaType` 可选值：
- `AUDIO`
- `PICTURE`
- `VIDEO`
- `ALL`

### 4.2 同步单个文件

```kotlin
fun syncSingleFile(
    savePath: String,
    mediaType: ValueUtil.CxrMediaType,
    fileName: String
): Boolean {
    return CxrApi.getInstance().syncSingleFile(savePath, mediaType, fileName, syncCallback)
}
```

`fileName` 为眼镜端文件路径。

### 4.3 停止同步

```kotlin
fun stopSync() {
    CxrApi.getInstance().stopSync()
}
```

---

### 开发建议

- **传输前置校验**：在 `sendStream`、`getUnsyncNum` 等调用前，推荐先检查 `isBluetoothConnected`。
- **路径与权限**：同步文件时要确保 `savePath` 可写，并根据 Android 版本处理动态存储权限。
- **大文件策略**：同步视频等大文件时，建议提示用户保持设备靠近且 Wi-Fi 信号稳定。
- **回调解耦**：可结合协程或 RxJava 对回调进行包装，简化业务层的状态管理。

